## 목차
[[3-1 과제의 발제]]
[[3-2 과제의 요건]]
[[3-3 과제의 구현 _ 기본 설계]]
[[3-4 과제의 구현 _ 심화 설계]]
[[3-5 과제의 이론 _ 설계를 위한 이론]]
[[3-6 과제의 이론 _ 설계를 위한 이론]]
[[3-7 과제의 이론 _ 설계를 위한 이론]]
[[3-8 과제의 이론 _ 설계를 위한 이론]]
[[3-9 과제의 이론 _ 설계를 위한 이론]]
[[3-10 과제의 회고 (WIL + KPT)]]
[[3-11 과제의 발전 _ 추가 고려사항]]

# Chapter 2-1 서버구축
 👑 명예의 전당


- **참고하면 좋은 사례**
    - Repo 구현체를 나누어서 동시성 문제확인한 케이스
- **가장 많이하는 실수**
    - 테스트 메세지 = “이미 수강신청한 경우 실패()”
        - 테스트 메세지명 “조건과 기대값이 명확해야한다.”
        - “수강 신청시, 이미 수강한 경우 DuplicatedException이 발생한다.”
            - “???: 모르는데 어떻게 리뷰해요?”
    - lock 사용시 메소드명 명시
        - XxxxwithLock, XxxxForUpdate

 🎯 **들어가면서, TDD와 클린아키텍처 적용하기**

- TDD Chapter Summary
    
    ### 실제 현업에서 TDD 를 진행한다면 ?
    
     💡 TDD 는 **테스트가 중요하다** 를 인지하는 것부터 시작됩니다.
    
    
    
    우리가 **TDD** 가 왜 궁금하고, 왜 배우고 싶고, 왜 요즘 업계에서 자주 언급되는 지에 대해서 먼저 생각을 해보면 결국 뿌리는 **테스트가 중요하다** 를 인지 해야 하기 때문입니다. 약 3주간 TDD 챕터를 진행하며 주어진 시나리오를 기반으로 기능을 구현하고, 테스트 코드를 작성해보면서 어떻게 테스트 코드를 활용해 내 코드를 견고하게 할 지를 배워보았습니다.
    
     ❌ **우리에게 TDD 가 어려웠던 이유
	1.** **[ 경험 ]** Test Code 를 작성해본 적이 없다. 
    **2.** **[ 분석 ]** 요구사항을 분석하고 기능을 작성할 때, 어떤 테스트가 필요한지 모르겠다. 
	**3.** **[ 시간 ]** 기능 개발하기에도 바쁜데, 테스트 코드 작성할 시간적 리소스는 더욱이 부족하다.
    **4.** **[ 구조 ]** 내가 작성한 코드를 어떻게 테스트해야할지 모르겠다 ( feat. private method )
    
    
    
    최소한의 노력으로 우리 코드를 안전하게 보호하기 위해서 테스트가 필요하다는 점, 미연에 문제를 방지하기 위해서 꼭 필요하다는 점은 이제 인지했습니다. 그럼 우리가 TDD 를 현업에서 사용하기 위해선 어떤 규칙을 지켜나가야 할까요 ?
    
     💡 **내가 기능을 개발하는 방법 ( Feat. Unit Test )**
    
    1. ****요구사항을 분석 ( 어떤 기능을 제공해야하는지 )
    2. 실패하면 안되는 Input 을 정리 ( 실패 TC 에 대해 정의 )
    3. 2번의 TC 를 모두 만족시킬 수 있도록 기능을 구현
    4. 기능의 책임을 분석
        - 너무 다양한 TC 가 필요하지 않았는지
        - 너무 많은 책임이 주어져 있지는 않은지 ( 응집도 )
    5. 리팩토링
        - 적절한 위상의 책임을 가지고 있도록
        - 충분히 원자적으로 테스트가 가능하도록
    
    
    
    어렵고 도입하기도 쉽지 않았지만, 그래도 TDD를 하면 테스트코드만 잘 작성하는 것이 아닌, 서비스 코드에 대한 설계가 좀 더 나아진 것 같은 느낌이 들지는 않았나요?
    
     💡 **TDD를 하면서 더 나은 클래스 설계가 되었어요.**
    
    - 하나의 클래스에서 너무 많은 로직을 담지 않고 적절히 역할을 분리해야.. 그래야 테스트코드를 쉽게 짤 수 있더라고요..
    - 주구장창 로직부터 작성하지 않고, 어떤 역할을 하는 클래스들이 구조화되어야 하는지 미리 고민하게 되었어요. 테스트 코드를 먼저 작성하려면, 어떤 클래스들이 있어야 하고, 각각의 클래스가 무슨 역할을 해야할지 미리 생각해봐야 테스트코드를 작성할 수 있었어요. 
- 클린아키텍처 잘 적용 했는지 아는 방법
    
    ### 실제 소프트웨어 아키텍처를 적용한다면 ?
    
     💡 Domain ? Entity ? 이게 뭐요..
    
    
    
    용어에서부터 벽이 느껴질 때가 있는데, 바로 위와 같이 여기저기서 쓰이는 용어들입니다. 심지어는 상황에 따라 달라지는 이 용어들로 소통하다보면, 서로 다른 이야기를 하는 경우도 종종 있는 것 같아요. 앞서 우리가 살펴본 소프트웨어 아키텍처 패턴에서 또한 용어의 다른 뜻 때문에 헷갈리는 분들이 많았을 거라고 생각해요. 그래서 좀 보편적으로 이해해보면 좋을 것 같습니다.
    
    - **도메인** ( Domain )
        - 특정 기능과 관련된 속성, 기능 등을 응집화시킨 개념
        - e.g.
            - 도메인 이해도가 높아야 한다. = 해당 기능을 구성하는 하위 도메인에 대한 유기적 흐름 이해가 가능하다.
            - 도메인 모델 = 기능적으로 군집화시켜놓은 개념으로 일반적으로는 그 도메인을 표현하는 객체를 의미하며 POJO 일수도, JPA Entity 를 도메인 모델로 사용할 수도 있다.
            - 도메인 url = 하위 uri를 그루핑할 수 있는 응집화된 url
    - **엔티티** ( Entity )
        1. 도메인을 설명할때 말하는 엔티티 : 도메인 모델의 맥락에서 `특정 주제에 대한 속성 기능을 응집화시켜놓은 도메인 모델`
        2. DB 와 연관지어 말하는 엔티티 : DB 테이블이나 그 `테이블에 매핑되는 객체`
    
    그렇다면 도메인 맥락에서 db 엔티티와 분리되어 있다라는 말은 “나는 비즈니스 로직을 표현하기 위한 `“도메인 객체”를 DB 의 엔티티와는 상관없게` 표현할거야“ 라고 설명할수 있고, 그와 반대로 `DB 엔티티 (e.g. JPA Entity) 를 비즈니스의 대상이 되는 도메인 모델`로서 정의할 수도 있겠죠.
    
    만약 `도메인 모델 != 엔티티 라는 설계`를 통해 아예 데이터베이스와 별개로 나는 비즈니스 로직을 강한 응집도를 주고, 외부의존성은 내 비즈니스 룰을 따라야 해! 라는 룰을 가져간다면 도메인영역 (핵심 비즈니스 로직) 은 엔티티를 모를테고, 이 경우 엔티티를 통해 db와 상호작용하는 datasource layer는 도메인 -> 엔티티, 엔티티 -> 도메인 의 작업을 수행하여 “`내가 아는 언어`” 로 변경해야 합니다.
    
     💡 시작은 패키지부터. 유연성을 보장하고 확장 가능한 패키지 구조.
    
    
    
    멘토링하면서 혹은 현업에서 항상 가장 많이 받는 질문 중 하나입니다. 멀티 모듈은 어떻게 구성하는 게 좋을까요 ? 패키지는 어떻게 나누는게 좋을까요 ? 이런 질문들을 항상 받곤 하는 것 같아요. 그래서 저라면 어떤 관점에서 설계할 것인가를 적어보았습니다.
    
    일단 기본은 앞서 발제 때, 코칭 때 설명한 것과 같이 비즈니스 로직을 보호하기 위해 Repository 를 추상화하여 비즈니스 로직이 DB 와 실제 상호작용하는 부분을 모르게 할 거예요. 그 이유는 내 비즈니스는 어떻게 어디에서 무엇을 가져오는지에 관심을 가지기보다 내가 수행해야할 기능에 집중하도록 작성하기 위해서입니다.
    
    ```kotlin
    api/
      도메인/
    	  controller
    	  dto/
    		  (request, response models)
    domain/
    	도메인/ (user, lecture, comment, ...)
    		(Models)
    		- Lecture
    		- ApplicationHistory
    		(Service)
    		- LectureService
    		(Repositories)
    		- LectureReader (I/F)
    		- LectureStore (I/F)
    		infrastructure/
    			- LectureCoreReaderRepository (IMPL)
    			- LectureCoreStoreRepository (IMPL)
    			- LectureJpaRepository (JPA)
    			- LectureCustomRepository (QueryDSL)			
    ```
    
    위와 같이 나누어 놓고 보니, **도메인** 별로 강한 응집도를 가진 패키지 구조를 가지게 되었습니다. 만약 내가 User 를 개발하면서 Lecture 에 대한 정보를 사용해야 한다면, `lecture` 패키지만 보면 모든 것을 파악할 수 있게 됩니다.
    
    만약 서버를 분리해야 한다 ? 하면 도메인을 뚝 떼서 가져다가 새로운 프로젝트를 구성해도 되겠죠.
    
    하지만 우리는 일반적으로 API 서버만 작성하는 것이 아니라 관리자 ( Admin ) 애플리케이션도 같이 작성하곤 합니다. 대상은 다르지만 같은 도메인 컨텍스트를 공유하기 때문이죠.
    
    그런 경우, 저는 뷔페식 패키지 구조를 가져가기 위해 서비스를 잘게 나누고 비즈니스 로직의 완성을 Service 가 아닌 각 애플리케이션의 UseCase 단위로 조립할 수 있도록 변경합니다.
    
     💡 뭐 좋아할지 몰라 다 차려놨어. 먹고 싶은 거 가져다가 알아서 먹어. - alen
    
    ```kotlin
    admin/
    	도메인/
    		view/
    		usecase/
    			- ModifyLectureUseCase
    			- GetMyApplicationsUseCase
    api/
      도메인/
    	  controller
    	  dto/
    		  (request, response models)
    	  usecase/
    		  (Usecase = 각 비즈니스에 맞춰 component 조립)
    		  - ApplyLectureUseCase
    		  - GetLecturesUseCase  
    domain/
    	도메인/ (user, lecture, comment, ...)
    		(Models)
    		- Lecture
    		- ApplicationHistory
    		(Components)
    		- LectureReader
    		- LectureModifier
    		- ApplicationManager
    		(Repositories)
    		- LectureReaderRepository (I/F)
    		- LectureStoreRepository (I/F)
    		infrastructure/
    			- LectureCoreReaderRepository (IMPL)
    			- LectureCoreStoreRepository (IMPL)
    			- LectureJpaRepository (JPA)
    			- LectureCustomRepository (QueryDSL)
    ```
    

 ⛵ **이번 챕터 목표**

- **아키텍처와 테스트에 집중하며, 시나리오 기반 서버 애플리케이션 구축**
- 아키텍처와 테스트 코드 작성에 집중하며, 견고하고 유연한 서버 개발을 지향합니다.

 🚩 **What to do: 이번 챕터에 해야 할 것. 이것만 집중하세요!**



### 1. Service Scenario 선택

 💡 우리는 적절한 아키텍처 패턴, 클린 코드, 테스트 등을 준수하며 유지, 성장 가능한 애플리케이션을 만들어야 합니다.



### 시나리오를 선택해 서버 애플리케이션 구축

**`기본과제` :** 각 시나리오의 기본 요구사항 **`심화과제`** : 각 시나리오의 심화 요구사항

 ❓

아키텍처와 테스트 코드 작성에 집중하며, 견고하고 유연한 서버 개발이 목표인 사람 (챌린지 과제가 포함되어 있습니다)

[[3-2 과제의 요건]]


### **2. 개발 환경 준비**

- **Architecture**
    - Testable Business logics
    - Layered Architecture Based
    - (+) Clean / Hexagonal Architecture
- **DB**
    - MySql 8.0 ( docker )
- **DB ORM**
    - JPA / MyBatis
    - TypeORM / Prizma
- **Test**
    - JUnit + AssertJ
    - Jest / Mocha
    - Testcontainers

**Template ( + testcontainers )**

[java](https://github.com/kkj5158/hh_Plus_3)

### **3. 시나리오 분석 및 작업 계획**

- **항해 플러스 서버 구축 프로젝트 Milestone**
- **시나리오 요구사항 분석**
    - **시퀀스 다이어그램**
        ![[Untitled 1.png]]

        
        > 출처: [https://www.softwareideas.net/](https://www.softwareideas.net/)
        
- **API 명세**
    - `Endpoint` - API 의 URL 및 기능을 설명할 수 있는 적절한 HTTP Method
    - `Request` - Param, Query, Body 등 API 호출 시 전달되어야 할 매개변수 및 데이터
    - `Response` - API 의 응답 코드, 데이터 등에 대한 명세 및 적절한 예제
    - `Error` - API 호출 중 발생할 수 있는 예외 케이스에 대해 명시
    - `Authorization` - 필요한 인증, 권한에 대해서도 명시
- **ERD 설계**
    - 요구사항 해결을 위한 도메인의 분석 및 테이블 설계 역량

**Mock API 로 생산성 극대화**

- API Spec 을 정했다면, 최대한 빠르게 Mock API 를 작성해 배포해야 함
    
    - 우리는 혼자 일하는 게 아니다!
    - API Spec 이 정해졌다면, 그 API 를 활용하는 다른 동료 ( 프론트엔드, 다른 백엔드 팀 등 ) 이 Dummy 데이터로 시뮬레이션을 할 수 있어야 함.
    
     ℹ️ curl, http (intellij), postman 등으로 API 시뮬레이션을 할 수 있어야 합니다.
    
    
    
- **CI/CD 공부 참고 자료**
    
    [CI/CD 배포 파이프라인 구축](https://www.notion.so/CI-CD-1692dc3ef5148158902ee2750053eb94?pvs=21)
    

 🚩 **과제 : 이번 챕터 과제**

### 시나리오를 선택해 서버 애플리케이션 구축

**`기본과제` :** 각 시나리오의 기본 요구사항 **`심화과제`** : 각 시나리오의 심화 요구사항

 ❓

아키텍처와 테스트 코드 작성에 집중하며, 견고하고 유연한 서버 개발이 목표인 사람 (챌린지 과제가 포함되어 있습니다)

[e-커머스 서비스](https://www.notion.so/e-16d2dc3ef51481d28982f2e7d2266f6a?pvs=21)

[맛집 검색 서비스 (번외편)](https://www.notion.so/16d2dc3ef514810583d5cd29e118431a?pvs=21)

[콘서트 예약 서비스](https://www.notion.so/16d2dc3ef5148151a020e1eaa15cf6ec?pvs=21)



 🗓️ **Weekly Schedule Summary: 이번 챕터의 주간 일정 (각 요일 자정까지 제출)**



**`REPO를 새로 생성하셨다면 이것부터 세팅해주세요!`**

- PR 템플릿 세팅하기!
    - Repo를 생성하고 `.github` 폴더를 생성 후 `pull_request_template.md` 파일을 만들어서 아래 템플릿을 복사/붙여넣기해주세요!
        
    - PR 템플릿
        
        ```markdown
        ### **커밋 링크**
        <!-- 
        좋은 피드백을 받기 위해 가장 중요한 것은 코드를 작성할 때 커밋을 작업 단위로 잘 쪼개는 것입니다.
        모든 작업을 하나의 커밋에 진행하고 PR을 하면 구조 파악에 많은 시간을 소모하기 때문에 절대로
        좋은 피드백을 받을 수 없습니다.
        
        필수 양식)
        커밋 이름 : 커밋 링크
        
        예시)
        동시성 처리 : c83845
        동시성 테스트 코드 : d93ji3
        -->
        
        ---
        ### **리뷰 포인트(질문)**
        - 리뷰 포인트 1
        - 리뷰 포인트 2
        <!-- - 리뷰어가 특히 확인해야 할 부분이나 신경 써야 할 코드가 있다면 명확히 작성해주세요.(최대 2개)
          
          좋은 예:
          - `ErrorMessage` 컴포넌트의 상태 업데이트 로직이 적절한지 검토 부탁드립니다.
          - 추가한 유닛 테스트(`LoginError.test.js`)의 테스트 케이스가 충분한지 확인 부탁드립니다.
        
          나쁜 예:
          - 개선사항을 알려주세요.
          - 코드 전반적으로 봐주세요.
          - 뭘 질문할지 모르겠어요. -->
        ---
        ### **이번주 KPT 회고**
        
        ### Keep
        <!-- 유지해야 할 좋은 점 -->
        
        ### Problem
        <!--개선이 필요한 점-->
        
        ### Try
        <!-- 새롭게 시도할 점 -->
        ```
        

### **`STEP 05`**

- 시나리오 선정 및 프로젝트 Milestone 제출
    
- 시나리오 요구사항 별 분석 자료 제출
    
    > 시퀀스 다이어그램, 플로우 차트 등
    

### **`STEP 06`**

- ERD 설계 자료 제출
- API 명세 및 Mock API 작성
- Github Repo 제출 ( 기본 패키지 구조, 서버 Configuration 등 )

---

### FAQ

- 저는 다른 아키텍처들도 시도해보고 싶은데요 !
    
    Q : 요즘 Clean , Hexagonal , Vertical Slice 등 다양한 아키텍처에 대한 이야기가 들려옵니다. 이런 것들을 이용해볼 수는 없을까요 ?
    
    A : 물론 가능합니다 ! 클린 아키텍처는 DDD 기반으로 도메인 중심의 설계에 효율적이며 헥사고날 아키텍처는 보통 잘게 나눈 도메인에 기반한 MSA 에 효율적인 아키텍처입니다. 이는 실제로 SOLID 원칙을 잘 지킨 하에, 레이어드 아키텍처와 함께 녹여내어 현업에서 사용하는 아키텍처입니다. 그래서 러닝커브로 인한 프로젝트의 지연보다는, 우선적으로 기본에 충실한 구현을 진행하고 차후 리팩토링 등을 통해 고도화된 아키텍처의 도입을 시도해보는 것을 추천드립니다.
    
- TDD 가 아닌 DDD 로 개발하는 것은 안될까요 ?
    
    A : DDD 와 TDD 는 같은 범주로 묶이는 개발론이 아닙니다. DDD 는 기존 DB 테이블 중심적으로 설계하고, 서비스를 구성하는 방식보다 요구사항에 대해 도메인을 명확히 분석하고, 도메인이 주체가 되도록 기능을 개발하는 방식을 의미합니다. 즉, 설계론적인 의미에서 더 많은 이점을 찾고자 하는 개발론이죠. TDD 는 개발하는 방식을 테스트적인 관점에서 바라보는 방법론입니다. 이에 DDD 로 개발할 때는 각 도메인의 컨텍스트를 보다 명확하게 정의하고, 기능을 단순화하고 정확하게 표현할 수 있어야 합니다.
    
    A : 위에 설명한 바처럼 오히려 DDD 기반의 설계와 구현에 대해 익숙하고 잘 정의되어 있다면 TDD 방법론을 이용해 개발을 진행하기에 오히려 적합한 구조를 갖출 수 있다고 생각해요. TDD 는 각 기능에 대해 작은 단위로 구성하고 Unit Test 부터 잘 작성해나가며 빠른 주기로 개발/테스트/리팩토링을 반복해나가며 기능을 완성해나가는 방식인데, 도메인이 잘 정의되어 있고 기능에 대한 책임이 명확히 나뉘어져 있다면 더 빠른 개발을 진행할 수 있습니다.
    
- 위 서비스 3개를 선정한 기준이 어떻게 되나요?
    
    A : 기존 기수에서는 팀프로젝트에 집중해 규모 있는 시나리오 기반의 큰 프로젝트를 같이 설계하고 테스트 코드, 팀 컨벤션 등 다양한 역량을 기르도록 하는 것이 목표였습니다. 하지만 기능이 다양해지고 많아지다보니 각자가 경험해보고 쌓을 수 있는 역량이 팀원별로 상이해지는 부분들이 있었고, 단순 구현 보다는 이번 챕터에서 백엔드 개발자로서 쌓아야 할 역량에 대한 집중도가 다소 떨어지는 경향을 확인했습니다.
    
    A : 이에 개개인의 역량 집중 뿐만 아니라, 팀 내에서 서로 다른 생각과 접근 등을 공유하고 피드백할 수 있는 환경을 만들어 더 많은 인사이트를 가져갈 수 있는 방향성으로 시나리오를 전면 재설계 하였습니다.