## 목차
[[2_1 과제의 발제]]
[[2_2 과제의 요건]]
[[2_3 과제의 분석]]
[[2_4 과제의 구현 _ 기본 기능의 구현]]
[[2_5 과제의 구현 _ 단위테스트 작성 및 구현]]
[[2_6 과제의 구현 _ 상세 정책의 구현]]
[[2_6 과제의 구현 _ 통합테스의 작성 및 구현]]
[[2_7 과제의 이론 _ 클린코드를 위한 아키텍쳐]]
[[2_8 과제의 이론 _ JPA의 기초 이론]]
[[2_9 과제의 이론 _ JPA의 심화 이론]]
[[2_10 과제의 이론 _ JPA와 클린아키텍쳐]]
[[2_11 과제의 이론 _ 동시성 처리에 대한 심화이론]]
[[2_12 과제의 회고 (WIL + KPT)]]
[[2_13 과제의 발전 _ 추가 고려사항]]


# Chapter 1-2 TDD & 클린아키텍처


## 👑 명예의 전당

- 참고하면 좋은 사례
    
    - 김용철
        
        [Step01 제출 by zxcv9203 · Pull Request #1 · zxcv9203/tdd](https://github.com/zxcv9203/tdd/pull/1)
        
    - 김경덕
        
        [dev by geonduck · Pull Request #1 · geonduck/hhplus-tdd-jvm](https://github.com/geonduck/hhplus-tdd-jvm/pull/1)
        
- 가장 많이하는 실수
    
    - 커밋 & PR
    - 동시성 이슈
    - 잠금 효용
    - 테스트 코드

##  🔄 Summary : TDD 챕터 돌아보기

### 실제 현업에서 TDD 를 진행한다면 ?

- 💡 TDD 는 테스트가 중요하다 를 인지하는 것부터 시작됩니다.

우리가 TDD 가 왜 궁금하고, 왜 배우고 싶고, 왜 요즘 업계에서 자주 언급되는 지에 대해서 먼저 생각을 해보면 결국 뿌리는 테스트가 중요하다 를 인지 해야 하기 때문입니다. 약 1주간 TDD 챕터를 진행하며 나아가, 10주간 항해플러스를 진행하면서 주어진 시나리오를 기반으로 기능을 구현하고, 테스트 코드를 작성해보면서 어떻게 테스트 코드를 활용해 내 코드를 견고하게 할 지를 배울 겁니다.

 ❌ 우리에게 TDD 가 어려웠던 이유 
1. [ 경험 ] Test Code 를 작성해본 적이 없다. 
2. [ 분석 ] 요구사항을 분석하고 기능을 작성할 때, 어떤 테스트가 필요한지 모르겠다. 
3. [ 시간 ] 기능 개발하기에도 바쁜데, 테스트 코드 작성할 시간적 리소스는 더욱이 부족하다.
4. [ 구조 ] 내가 작성한 코드를 어떻게 테스트해야할지 모르겠다 ( feat. private method )    


 💡 TDD를 하면서 더 나은 클래스 설계가 되었어요.

- 주구장창 로직부터 작성하지 않고, 어떤 역할을 하는 클래스들이 구조화되어야 하는지 미리 고민하게 되었어요. 테스트 코드를 먼저 작성하려면, 어떤 클래스들이 있어야 하고, 각각의 클래스가 무슨 역할을 해야할지 미리 생각해봐야 테스트코드를 작성할 수 있었어요. 
- 하나의 클래스에서 너무 많은 로직을 담지 않고 적절히 역할을 분리해야.. 그래야 테스트코드를 쉽게 짤 수 있더라고요..    



## 🎯 들어가면서, Why 클린아키텍처?

###  클린 아키텍처, 헥사고날 아키텍처 등 다양한 아키텍처 패턴들을 다 알아야 하나요 ?

우리는 단순히 특정 요구사항을 만족하는 기능을 제공하는 애플리케이션을 작성하고 끝나는 것이 아닌 유지 보수 및 지속적으로 서비스가 성장 가능하도록 하는 구조를 고민해보아야 합니다. 이를 위해서는 효율적으로 개발하고, 유지보수 할 수 있도록 다양한 룰을 정해야 합니다.

가독성을 높여 코드를 누구나 쉽게 파악할 수 있게 한다던지, 쉽게 변경할 수 있도록 다양한 원칙을 도입한다던지 하는 것들이 이에 속합니다. 그리고 이런 것들을 기본적으로 포함하고, 지켜질 수 있도록 하는 룰이 우리가 흔히들 들을 수 있는 클린, 헥사고날, 레이어드 등의 아키텍처 패턴 들입니다. 우리는 이를 학습하고 좋은 소프트웨어를 만들기 위한 규칙을 만들어 나가야 합니다.
### 클린 코드의 중요성

우리가 작성하는 코드, 언제든 이해하기 쉬울까요 ? 비즈니스 로직을 표현하다 보면, 코드의 복잡도는 높아지고 이를 이해하는 것은 쉽지 않을 수 있습니다. 이는 다른 개발자들과 함께 일할 때, 혹은 유지보수할 때 코드의 가독성 등에서 매우 중요하며 달성하기 위한 수많은 방법들이 존재합니다. 함수 네이밍, 주석부터 시작해서 응집도/결합도, 수많은 원칙 등 클린코드와 함께 따라오는 저마다의 노하우나 규칙들이 존재합니다.

우리는 무엇보다 변수, 함수 등이 스스로 내가 무엇인지, 어떤 일을 하는지 를 설명할 수 있어야 하고 명확하게 자신의 역할만을 수행하고 있는지 등에 주의해 코드를 작성하는 습관을 들이는 데에 노력을 기울여야 합니다.

### ⛵ 이번 챕터 목표

- 아키텍처와 테스트 코드 작성에 집중하며, 견고하고 유연한 서버 개발을 지향합니다. 
    
- 아키텍처와 테스트에 집중하며, 서비스의 백엔드 서버 구축
    
- 기초 학습자료로 부족한 부분을 학습합니다.
    
- 주어진 시나리오 중 하나를 택해 백엔드 서버를 구축합니다.
    

 🚩 학습자료 : 이번 챕터에 해야 할 것. 이것만 집중하세요!



### ℹ️ Software Architecture Pattern

 💡 좋은 아키텍처 패턴

- 지속적으로 성장 가능한 안정적인 소프트웨어를 잡기 위한 최고의 가이드라인
- 지켜야 할 기본적인 개발 가이드라인을 잡아주는 틀



#### 레이어드 아키텍처
![[레이어드 아키텍쳐.png]]

##### 🔔 Rules

- 상위 계층 → 하위 계층 호출의 단방향 흐름을 유지
- 상위 계층이 필요한 기능을 하위 계층의 구현으로 전달
- 하위 계층의 변경이 상위 계층에 영향을 줄 수 있음
- 비즈니스 로직이 핵심이 아니며 보호받지 못함.
- DIP 🆗 OCP ❎

#### 헥사고날 아키텍처
![[헥사고날 아키텍쳐.png]]
##### 🔔 Rules

- 애플리케이션의 핵심은 비즈니스 로직
- 데이터 계층 및 API 계층이 비즈니스 로직을 의존 ( Adapter & Port 패턴 )
- 다양한 외부 인터페이스 ( API, MessageQueue, WebSocket 등 ) 에 동일한 비즈니스 로직을 전달할 수 있도록 하는 아키텍처
- DIP 🆗 OCP 🆗

#### 클린 아키텍처
![[클린 아키텍쳐.png]]

##### 🔔 Rules

- 애플리케이션의 핵심은 비즈니스 로직
- 데이터 계층 및 API 계층이 비즈니스 로직을 의존 ( UseCase & Port 패턴 )
- 도메인 중심적인 고수준의 관심사 분리
- DIP 🆗 OCP 🆗

#### Clean + Layered Architecture
![[클린_레이어드_아키텍쳐.png]]
##### 🔔 Rules

- 애플리케이션의 핵심은 비즈니스 로직
- 데이터 계층 및 API 계층이 비즈니스 로직을 의존 ( 비즈니스의 Interface 활용 )
- 도메인 중심적인 계층 아키텍처
- Presentation 은 도메인을 API로 서빙, DataSource 는 도메인이 필요로 하는 기능을 서빙
- DIP 🆗 OCP 🆗

```java

// Presentation Layer (1)
class Controller {

}
// Business Layer
// 비즈니스 유즈케이스 계층 (2)
class xxFacade {
	private final AService aService;
	private final BService bService;
	private final CService cService;
	// 컨트롤러가 가져다 쓸 완성(조립)된 기능.
	// @Transactional // 옵셔널
	void myLogic() {
		transactionTemplate.startTransaction(() -> {
			service.a(transaction...
		});
		aService.a();
		bService.b();
		..
	}
}
// 비즈니스 로직 계층 (3)
class Service {
	private final Repository repository; // 의존성을 직접 주입받는 형태
	
	@Transactional
	void a() {
		
	}
}
interface UserRepository {
	// "나는 이게 필요하니까 니들이 어떻게든 가져와"
	UserPoint get(String userId);
}
여기까지는 순수 "우리 애플리케이션 코드"
-----
- Repository 추상 명세에 대한 구현체
- 그 명세의 기능을 제공하기 위해서 각종 온갖 잡기술들을 동원해서 기능을 제공해주는 게 목적
class UserCoreRepository implements UserRepository {
	// JpaRepository
	// QueryDSL
	
	void get~~ {
		Jpa 의 기능 이용	
	}
	
	void findBy~~~~	{
		Jpa 기능 이용 + 쿼리 DSL 기능 이용 => Map 으로 만들어서 반환
	}
	
	void findMyHeart~~~~ {
		QueryDSL 기능 이용
	}
}

// Persistence Layer (4)
// 세부 구현을 통해서 도메인이 필요하다는 기능을 제공해주는 친구를 만들어주기.
class RepositoryJpaImpl implements Repository {
	private final UserPointJpaRepository jpaRepository;
}
// JPA 구현체 = TypeORM, MyBatis, ...
interface UserPointJpaRepository extends JpaRepository<Long, UserPoint>

// 파사드 네이밍 어떻게 ..?
// "허재"라면 유즈케이스를 범용적으로 품을 수 있을지에 대해서 고려한다.

상품의 점수를 매기는 기능

record class ProductId(Long productId) { }
record class BrandId(Long branId) { }

class ScoreFacade {
	ProductService productService;
	CalculatorService calculatorService;
	InputValidator inputValidator;
	ScoreService scoreService;
	
	public Float score(ProductId productId) {
		inputValidator.xx()
		productService.xx()
		...
		return score;
	}
	
	public Float score(BrandId brandId) {
		
	}
}
											 ```

```java

/src
	/interfaces
		/api // Controller ..
			/common
				/filter
				/interceptor
			/user
			/point
			/product
	/application // usecase, facade... 
		/user
		/point
		/product
			ProductFacade.java
	/domain
		/user
		/point
		...
	/infrastructure
		//...
-------------
/src
	/user
		/domain
			UserService.java
		/infrastructure
	/product
		/controller
		/application
		/domain
		/infrastructure
	/..
```


### Clean Code 추구하는 것

- 읽기 쉽고 단순한 코드 - 코드는 누구나 쉽게 읽을 수 있어야 하며, 너무 많은 책임을 가지고 있지 않을 것
- 의존성 격리 - 모듈 간 미치는 영향을 최소화하기 위해 의존성 격리를 고려할 것
- 추상화 - 명세와 구현을 적절히 분리할 것
- 중복성 최소화 - 중복된 코드는 최대한 지양할 것

 🚩 과제 : 이번 챕터 과제

[[2_2 과제의 요건]]

 🗓️ Weekly Schedule Summary: 이번 챕터의 주간 일정 (각 요일 자정까지 제출)

## `이것부터 시작하세요!`

### 기본조건

(아래 사항을 만족하지 않을 시 STEP 3, STEP4는 Fail처리 됩니다)

- 아키텍처 준수를 위한 애플리케이션 패키지 설계
- 특강 도메인 테이블 설계 (ERD) 및 목록/신청 등 기본 기능 구현
- 각 기능에 대한 단위 테스트 작성

> 사용자 회원가입/로그인 기능은 구현하지 않습니다.

### `STEP 3`

- 설계한 테이블에 대한 ERD 및 이유를 설명하는 README 작성
- 선착순 30명 이후의 신청자의 경우 실패하도록 개선
- 동시에 동일한 특강에 대해 40명이 신청했을 때, 30명만 성공하는 것을 검증하는 통합 테스트 작성

### `STEP 4`

- 같은 사용자가 동일한 특강에 대해 신청 성공하지 못하도록 개선
- 동일한 유저 정보로 같은 특강을 5번 신청했을 때, 1번만 성공하는 것을 검증하는 통합 테스트 작성

### FAQ

- 저는 다른 아키텍처들도 시도해보고 싶은데요 !
    
    Q : 요즘 Clean , Hexagonal , Vertical Slice 등 다양한 아키텍처에 대한 이야기가 들려옵니다. 이런 것들을 이용해볼 수는 없을까요 ?
    
    A : 물론 가능합니다 ! 클린 아키텍처는 DDD 기반으로 도메인 중심의 설계에 효율적이며 헥사고날 아키텍처는 보통 잘게 나눈 도메인에 기반한 MSA 에 효율적인 아키텍처입니다. 이는 실제로 SOLID 원칙을 잘 지킨 하에, 레이어드 아키텍처와 함께 녹여내어 현업에서 사용하는 아키텍처입니다. 그래서 러닝커브로 인한 프로젝트의 지연보다는, 우선적으로 기본에 충실한 구현을 진행하고 차후 리팩토링 등을 통해 고도화된 아키텍처의 도입을 시도해보는 것을 추천드립니다.
    

### Q & A 

1. JPA 더티체킹 기능을 이용하는 경우에는 Repository에 update 메서드가 없어도 될 것 같은데 이러면 나중에 JPA가 아닌 다른 기술로 변경했을 때 문제가 발생할 수 있을 것 같습니다. 이런 경우에 어떻게 하면 좋을까요? 생각해본 방법은 RepositoryImpl에서 update 메서드를 구현하지 않은 채로 빈 메서드로 두거나 더티체킹을 이용하지 않고 명시적으로 업데이트 하는 방법이 있을 것 같습니다. 코치님은 어떤 식으로 풀어나가시는지 궁금합니다.
    
    ```
    저는 그정도 구현은 어느정도 감수한다...
    저는 보통 "save" 를 명시적으로 하는 걸 좋아하는데 ( 이 경우는 도메인 모델에서 JPA 를 적극적으로
    잘 활용하지 않는 경우 ) -> 장점으로 언급주신 더티체킹 활용하지 않는 경우
    
    더티체킹을 활용한다면 .. save 로직만 없는 거고..
    엔티티 개념에 대한 Repository 의 기능 명세 자체는 나중에 "save" 만 추가된다... 
    ( JPA 더티체킹 안 쓰면 .. )
    ---> 너무 구체적인 구현이 변경되는 것이므로 ( 소프트웨어 아키텍처 측면에서 변경이 큰 것 )
    ---> 그래서 변경이 일어날 수 밖에 없는데 --> 여기서 도메인 중 save 메서드가 추가되는 것만
    영향을 끼치도록 할 수 있는 것으로 장점이 충분히 드러날 것이다.
    
    더티체킹 안함 경우 ..
    Tx {
    	지지고 볶고 하는데 ( 여기서 쿼리가 자동으로 만들어져서 나중에 나가는게 아님 )
    	repository.save(엔티티);
    }
    ```
    
2. 도메인과 JPA용 엔티티를 분리해야 할까요? 도메인에 `@Entitiy` 어노테이션을 붙이면 도메인 쪽에서 JPA 로의 의존이 생길 것 같은데 이것도 분리해야 하는지 궁금합니다.
    
    ```
    이거 금지입니다.
    이전 기수에서 서커스한다고, 자기 잘한다고 까불면서 이거 한사람 많았음.
    근데, 제대로 한 사람이 아무도 없었음...
    그런데... 여기서 중요한 건 기업과제를 낸다...
    저는 "분리"합니다. ( 왜 ? 난 할 줄 알아 )
    근데... 여러분들은 "분리"해서 내면 보편적인 회사에서 싫어합니다..
    
    우리 까불지 말고... @Entity = 도메인 모델로 쓰자.
    ```
    
3. 이번 과제 mybatis 가 아닌 jpa로 하는 거겠죠..?
    
    ```
    넵 JPA 만 써주세요. PLZ ..
    그 분명...
    사전 스터디 ? 거기서 JPA 로 가이드가 나갔을 것..
    
    NEST 는 TypeORM 이 원래 기본인데... 코치님들과 대화해서 Prizma 얘기하시는 분도 있어서
    요거는 원만한 합의 보시길..
    ```
    
4. 과제 작업시에만 mysql이나 mariadb를 사용하고 제출 시 h2에서도 동작할 수 있도록 테스트 후 제출하는 거로 이해했는데.. 제가 이해한 부분이 맞을까요?
    
    ```
    mysql or mariaDB 가 실제 타겟 DB
    테스트 DB 로 꼭 mysql / mariaDB 를 써야해 ? X => 
    테스트 돌릴 때는 h2 를 써도 된다.
    ```
    
5. 과제 제출시 STEP3 + 기본 PR link를 STEP3에 제출하면 될까요? 아니면 STEP3에 해당하는 부분만 PR생성해서 제출하면 될까요?
    
    ```
    STEP 3 PR 에 링크 첨부해주시면 좋을 것 같습니다. README 링크를 넣든..
    혹은 커밋을 해당 PR 에 추가하든..
    ```
    
6. 과제 중에, “개인 작업 페이지에 기록 남기기” 라는 과제는 2주차 과제를 진행하면서 소화한 내용들을 블로그 혹은 노션에 기록을 남기는 것인가요?
    
    ```
    아마 그런 것 같구요... 이건 매니저님들께서 가이드를 주실 것 같습니다
    ```
    
7. 6번이 맞다면, 해당 글의 링크나 파일은 어떻게 제출을 하면 될까요?
    
    ```
    요거도 매니저님들께서 가이드를 주실 것 같습니다.
    ```
    
8. mysql, maria db를 사용하라 하셨는데, 테스트는 h2로 진행하라는게 어떤 의미인지 잘 모르겠습니다..동시성 이슈에 대한 해결 코드를 mysql, maria db에 기반한 기능을 이용하라(?) 는건가요!?!?
    
    ```
    위에서 설명된 거로 이해 완료!
    ```
    
9. 날짜별로 특강 목록이 있다고 적혀있는데 구현은 자유인가요?
    

- 예를들어 한달 기준으로 평일마다 특강이 있는지?  
    
- 하루에 특강이 여러개 있는지? (편집됨)
    
    ```
    자유이구요 대신 원하는 구현 방식에 따라서
    기조가 되는 요구사항 분석도 잘 나와야 합니다.
    
    하루에 특강이 여러개 있는 케이스 + 한달 기준으로 평일마다 특강 =>  똑같이 갈 수 있는거 아님 ?ㅋㅋㅋ
    한달 기준으로 평일마다 각 특강이 여러번 있음.
    
    "각 특강마다" n 회차 진행 / 특강이 여러개 있다.. / 그리고 각 강사별로 여러개의 특강이 있다...
    월요일 5시 : 허재의 특강 1회
    수요일 3시 : 허재의 특강 2회
    금요일 5시 : 허재의 특강 3회
    ```
    

1. "다수의 인스턴스로 어플리케이션" 이라는게 여러 서버를 띄운다는 의미인가요??
    
    ```
    넵 맞습니다. 여러대의 동일한 애플리케이션 서버가 있다고 가정합니다.
    그다음, 그 서로 다른 애플리케이션 서버 간의 "동시성 이슈" 는 어떻게 해결할까?
    를 RDBMS ( MySQL / MariaDB ) 기반으로 풀어내주세요.
    ```
    
2. `다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하라`고 가이드되어 있는데, 이 부분에 대해서 통합 테스트 작성 시 고려해서 코드를 작성하라는 의미를 내포하는 건가요?
    
    ```
    다수의 인스턴스를 띄우는 것은 필요 없다.
    동시성의 제어의 로직이 "애플리케이션" 에 의존적이면 안된다는 의미이다.
    ```
    
3. ERD툴 추천해주세요..
    
    ```
    mermaid ( 저는 잘 안 씀 )
    eraser.io
    draw.io
    dbdiagram.io
    
    EntityRelationshipDiagram << Database Table Diagram 이 아니다.
    엔티티 간의 "관계" 를 모식도로 표현한 것.
    ```
    
    [A Free Database Designer for Developers and Analysts](https://dbdiagram.io/)
    
    [Eraser – AI co-pilot for technical design](https://www.eraser.io/)
    
    [Flowchart Maker & Online Diagram Software](https://app.diagrams.net/)
    
    1. 테스트 관련해서 여러분들이 유념해야할 것.
    
    ```java
    테스트는 여러분들의 소스코드를 어디서 실행시키든 "추가적인 설정 없이" 실행 가능해야 합니다.
    ```