[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271200%27%20height=%27630%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271200%27%20height=%27630%27/%3e)

[https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fnestjs-unit-testing.png&w=3840&q=75](https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fnestjs-unit-testing.png&w=3840&q=75)

ì´ íŠœí† ë¦¬ì–¼ì€ NestJSì˜ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸(í…ŒìŠ¤íŠ¸ ë”ë¸”ì„ ì‚¬ìš©í•œ ëª¨ì˜ í¬í•¨)ì— ëŒ€í•´ ìì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

ì´ íŠœí† ë¦¬ì–¼ì„ ìµœëŒ€í•œ í™œìš©í•˜ë ¤ë©´ ì½”ë”©ê³¼ í•¨ê»˜Â **`npm run test:watch`**ë¡œì»¬ë¡œ ì‹¤í–‰í•˜ì—¬ ìš°ë¦¬ê°€ ì‘ì„±í•œ í…ŒìŠ¤íŠ¸ê°€ ì‹¤ì œë¡œ ì‹¤í–‰ë˜ëŠ” ëª¨ìŠµì„ í™•ì¸í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤!

ì´ íŠœí† ë¦¬ì–¼ì˜ ì½”ë“œë¥¼ í™•ì¸í•˜ë ¤ë©´Â [**Github repoë¥¼**](https://github.com/tomwray13/nestjs-unit-testing)Â ì°¸ì¡°í•˜ì„¸ìš” .

ì¤€ë¹„ê°€ ëë‚˜ìš”? ê°‘ì‹œë‹¤!

![https://www.tomray.dev/static/images/nestjs.png](https://www.tomray.dev/static/images/nestjs.png)

## **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë€ ë¬´ì—‡ì…ë‹ˆê¹Œ?**

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ì‘ì€ ë™ì‘ì„ í™•ì¸í•˜ëŠ” ì½”ë“œì˜ ìë™í™”ì…ë‹ˆë‹¤.

ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„ë˜ë©´ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” íƒì›”í•œ íˆ¬ì ìˆ˜ìµì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•˜ë©´ ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê±°ë‚˜ ê¸°ì¡´ ì½”ë“œë¥¼ ë¦¬íŒ©í„°ë§í•  ë•Œ ìì‹ (ë˜ëŠ” í”„ë¡œì íŠ¸ì— ì°¸ì—¬í•˜ëŠ” ë‹¤ë¥¸ ë™ë£Œ)ì˜ ë¯¸ë˜ ë²„ì „ì´ ë¹ ë¥´ê³  ìì‹  ìˆê²Œ ì‘ì—…í•  ìˆ˜ ìˆë„ë¡ í”„ë¡œì íŠ¸ì— íˆ¬ìí•˜ê²Œ ë©ë‹ˆë‹¤.

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë„ ê²©ë¦¬ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì¦‰, í…ŒìŠ¤íŠ¸ê°€ ì‘ë™í•˜ê¸° ìœ„í•´ ë‹¤ë¥¸ ì¢…ì†ì„±ì— ì˜ì¡´í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

ì œ ìƒê°ì—ëŠ” ì´ëŸ¬í•œ ê²©ë¦¬ ë¬¸ì œë¥¼ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ NestJSì—ì„œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ëŠ” ë° ê°€ì¥ ì–´ë ¤ìš´ ë¶€ë¶„ì´ë¯€ë¡œ ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” ë§ì€ ì˜ˆì œë¥¼ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤.

## **NestJSì—ì„œ ì¢‹ì€ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ë§Œë“œëŠ” ê²ƒì€ ë¬´ì—‡ì…ë‹ˆê¹Œ?**

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ ë¬´ì—‡ì¸ì§€ ì´í•´í•˜ê³  ë‚˜ë©´ ëŒ€ë‹¤ìˆ˜ì˜ ê°œë°œìê°€ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ í›Œë¥­í•œ ì•„ì´ë””ì–´ë¼ê³  ìƒê°í•œë‹¤ê³  ë§í•˜ëŠ” ê²ƒì´ íƒ€ë‹¹í•˜ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.

ê·¸ëŸ¬ë‚˜ ì œëŒ€ë¡œ êµ¬í˜„ë˜ì§€ ì•Šì€ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ìì‚°ë³´ë‹¤ëŠ” ì±…ì„ì´ ë” ì»¤ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë‹¤ìŒì€ ì´ íŠœí† ë¦¬ì–¼ ì „ì²´ì˜ ì˜ˆì œì—ì„œ êµ¬í˜„ë  ëª‡ ê°€ì§€ ê·œì¹™ì…ë‹ˆë‹¤.

- Alignment-Act-Assert íŒ¨ëŸ¬ë‹¤ì„ì— ë”°ë¼ ê° í…ŒìŠ¤íŠ¸ë¥¼ ì‘ê²Œ ìœ ì§€í•˜ì‹­ì‹œì˜¤.
- ìµœì¢… ê²°ê³¼/í–‰ë™ì— ì§‘ì¤‘
- êµ¬í˜„ ì„¸ë¶€ ì‚¬í•­ì„ í…ŒìŠ¤íŠ¸í•˜ì§€ ì•ŠìŒìœ¼ë¡œì¨ ì·¨ì•½ì„± ë°©ì§€

ì´ ì£¼ì œì— ëŒ€í•œ ì±… ì „ì²´ê°€ ì‘ì„±ë˜ì—ˆìœ¼ë¯€ë¡œ(ë‚˜ëŠ” ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì— ê´€í•œÂ [**Vladimirì˜ ì±…ì„**](https://enterprisecraftsmanship.com/book/)Â ì¶”ì²œí•©ë‹ˆë‹¤ ), ì¢‹ì€ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ë§Œë“œëŠ” ë°©ë²•ì— ëŒ€í•œ ìì‹ ì˜ ì˜ê²¬ì„ í˜•ì„±í•˜ë ¤ë©´ ë” ë§ì€ ì±…ì„ ì½ì–´ì•¼ í•©ë‹ˆë‹¤.

## **ê°„ë‹¨í•œ CRUD ì˜ˆ(ëª¨ì˜ ì—†ìŒ)**

NestJSì˜ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¿ë§Œ ì•„ë‹ˆë¼ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤ìŠµìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ì™„ì „ ì´ˆë³´ìë¼ë©´ ì´ ì„¹ì…˜ì´ ì í•©í•©ë‹ˆë‹¤! í…ŒìŠ¤íŠ¸ ë”ë¸”ê³¼ ëª¨ì˜ì— ëŒ€í•´ ë°°ìš°ê³  ì‹¶ë‹¤ë©´ ë‹¤ìŒ ì„¹ì…˜ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”.

ìš°ë¦¬ëŠ” íŠ¸ìœ—ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ëª‡ ê°€ì§€ ê¸°ë³¸ CRUD ê¸°ëŠ¥ì„ ê°–ì¶˜ ì„œë¹„ìŠ¤ë¥¼ êµ¬ì¶•í•œ ë‹¤ìŒ ì´ì— ëŒ€í•œ ëª‡ ê°€ì§€ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•  ê²ƒì…ë‹ˆë‹¤.

ë‹¤ìŒê³¼ ê°™ì€ ëª¨ë“ˆì„ ì¶”ê°€í•˜ëŠ” ê²ƒë¶€í„° ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤Â **`tweets`**.

`nest g module tweets`

ê·¸ëŸ° ë‹¤ìŒ íŠ¸ìœ— ì„œë¹„ìŠ¤ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

`nest g service tweets`

ì´ 2ê°œì˜ ëª…ë ¹ì„ ì‹¤í–‰í•˜ë©´ ë‚´ë¶€ì— 3ê°œì˜ íŒŒì¼ì´ í¬í•¨ëœ ë””ë ‰í„°ë¦¬ê°€ ìƒì„±ë©ë‹ˆë‹¤Â **`tweets`**.

```jsx
src  / tweets / tweets.module.ts
								tweets.service.spec.ts
								tweets.service.ts
```

NestJSê°€ ìš°ë¦¬ë¥¼ ìœ„í•´ ìƒì„±í•œ í…ŒìŠ¤íŠ¸ íŒŒì¼ì„ ì—½ë‹ˆë‹¤. íŒŒì¼Â **`tweets.service.spec.ts`**ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```tsx
// **tweets.service.spec.ts**

import { Test, TestingModule } from '@nestjs/testing';
import { TweetsService } from './tweets.service';

describe('TweetsService', () => {
  let service: TweetsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [TweetsService],
    }).compile();

    service = module.get<TweetsService>(TweetsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
```

ì•„ì§ ìˆ˜í–‰í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ë‹¤ìŒ ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ ë¡œì»¬ì—ì„œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.

`npm run test:watch`

í„°ë¯¸ë„ì€ ë‹¤ìŒì„ ì¶œë ¥í•´ì•¼ í•©ë‹ˆë‹¤.

[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271200%27%20height=%27397%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271200%27%20height=%27397%27/%3e)

[https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fnpm-run-test-watch.png&w=3840&q=75](https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fnpm-run-test-watch.png&w=3840&q=75)

ì˜ í•˜ì…¨ì–´ìš”! ì´ì œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ í•« ë¦¬ë¡œë”©ìœ¼ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤. ì½”ë“œë¥¼ ë³€ê²½í•˜ë©´ í…ŒìŠ¤íŠ¸ê°€ ë‹¤ì‹œ ì‹¤í–‰ë©ë‹ˆë‹¤.

ë” ë§ì€ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ê¸° ì „ì— ìë™ ìƒì„±ëœ NestJS í…ŒìŠ¤íŠ¸ íŒŒì¼ì„ ì‚´í´ë³´ê³  ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ê³  ìˆëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

ìš°ì„  íŒŒì¼ëª…ì— ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œÂ **`spec.ts`**JestÂ [**(**](https://jestjs.io/)Â NestJSì—ì„œ ì‚¬ìš©í•˜ëŠ” í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬)ê°€ ìë™ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ì„ íƒí•©ë‹ˆë‹¤. í”„ë¡œì íŠ¸ì˜ ë‹¤ë¥¸ íŒŒì¼ì€Â **`spec.ts`**Jestì— ì˜í•´ ì„ íƒë©ë‹ˆë‹¤.

íŒŒì¼ ìì²´ ë‚´ì—ì„œëŠ” ë¸”ë¡ìœ¼ë¡œ ì‹œì‘ë©ë‹ˆë‹¤Â **`describe`**.

**íŠ¸ìœ—.service.spec.ts**

`describe('TweetsService', () => { *// ...*});`

ë¸”ë¡ ì˜ ëª©ì ì€Â **`describe`**ê´€ë ¨ í…ŒìŠ¤íŠ¸ë¥¼ ê·¸ë£¹í™”í•˜ëŠ” ê²ƒì´ë¯€ë¡œ ì—¬ê¸°ì„œëŠ”Â **`TweetsService`**.

ë‹¤ìŒìœ¼ë¡œ í›„í¬ê°€ ìˆìŠµë‹ˆë‹¤Â **`beforeEach`**.

**íŠ¸ìœ—.service.spec.ts**

`import { Test, TestingModule } from '@nestjs/testing'; import { TweetsService } from './tweets.service';

describe('TweetsService', () => { let service: TweetsService;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ providers: [TweetsService], }).compile();

```
service = module.get<TweetsService>(TweetsService);
```

});

_// ..._});`

í›„í¬Â **`beforeEach`**ëŠ” ê° í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— ë°œìƒí•´ì•¼ í•˜ëŠ” ëª¨ë“  ì„¤ì • ì‘ì—…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.

ë”°ë¼ì„œÂ **`beforeEach`**ì—¬ê¸°ì„œ í›„í¬ê°€ ìˆ˜í–‰í•˜ëŠ” ì‘ì—…ì€ NestJS ë‚´ì¥Â **`Test`**í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²©ë¦¬ëœ NestJS ëŸ°íƒ€ì„ì„ ìƒì„±í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤(ë”°ë¼ì„œ ì¢…ì†ì„± ì£¼ì…ê³¼ ê°™ì€ ëª¨ë“  NestJS ë™ì‘ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤).

ì´ ëŸ°íƒ€ì„ì€ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•  ë•Œ ì •ì˜í•œ ë‚´ìš©ìœ¼ë¡œ ì œí•œë©ë‹ˆë‹¤Â **`Test`**. ìœ„ì˜ ì˜ˆì—ì„œëŠ”Â **`TweetsService`**.

ë”°ë¼ì„œ ì´ ì„¤ì •ì„ í†µí•´Â **`TweetsService`**.

ìë™ ìƒì„±ëœ NestJS í…ŒìŠ¤íŠ¸ íŒŒì¼ì—ì„œ ê²€í† í•  ë§ˆì§€ë§‰ ë¶€ë¶„ì€ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤!

ë‹¤ìŒê³¼ ê°™ì€ í…ŒìŠ¤íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤Â **`it should be defined`**.

**íŠ¸ìœ—.service.spec.ts**

`import { Test, TestingModule } from '@nestjs/testing'; import { TweetsService } from './tweets.service';

describe('TweetsService', () => { *// ...*it('should be defined', () => { expect(service).toBeDefined(); }); });`

**`expect`**Jestì˜ í•¨ìˆ˜ë¥¼Â ì‚¬ìš©í•˜ëŠ” ê²ƒì€Â [**ì–´ì„¤ì…˜**](https://en.wikipedia.org/wiki/Test_assertion)Â ì…ë‹ˆë‹¤ .

ëª¨ë“ Â **`expect`**ê¸°ëŠ¥ì—ëŠ” íŠ¹ì • ì¡°ê±´ì´ ì¶©ì¡±ë˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ë˜ ë‹¤ë¥¸ ë°©ë²•ì´ ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

ì´ ì˜ˆì—ì„œëŠ” ì…ë‹ˆë‹¤Â **`toBeDefined()`**. ë”°ë¼ì„œ ì´ í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ê°€ ì •ì˜ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤Â **`TweetsService`**.

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì— ëŒ€í•œ ì¢€ ë” êµ¬ì²´ì ì¸ ì˜ˆë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

íŒŒì¼ ë‚´ë¶€ì—Â **`tweets.service.ts`**ëª‡ ê°€ì§€ CRUD ë©”ì„œë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

**íŠ¸ìœ—.service.ts**

`import { Injectable } from '@nestjs/common';

@Injectable() export class TweetsService { tweets: string[] = [];

createTweet(tweet: string) { if (tweet.length > 100) { throw new Error(`Tweet too long`); } this.tweets.push(tweet); return tweet; }

updateTweet(tweet: string, id: number) { const tweetToUpdate = this.tweets[id]; if (!tweetToUpdate) { throw new Error(`This Tweet does not exist`); } if (tweet.length > 100) { throw new Error(`Tweet too long`); } this.tweets[id] = tweet; return tweet; }

getTweets() { return this.tweets; }

deleteTweet(id: number) { const tweetToDelete = this.tweets[id]; if (!tweetToDelete) { throw new Error(`This Tweet does not exist`); } const deletedTweet = this.tweets.splice(id, 1); return deletedTweet; } }`

ì´ ì˜ˆì œë¥¼ ë‹¨ìˆœí•˜ê²Œ ìœ ì§€í•˜ê¸° ìœ„í•´ ì´ë¼ëŠ” í´ë˜ìŠ¤ì— ê³µê°œ í•„ë“œë¥¼ ìƒì„±í•˜ì—¬ ìƒíƒœê°€ ë©”ëª¨ë¦¬ì—ì„œ ì²˜ë¦¬ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤Â **`tweets`**.

íŠ¸ìœ— ì„œë¹„ìŠ¤ì˜ ì²« ë²ˆì§¸ ë©”ì†Œë“œì— ëŒ€í•´ í…ŒìŠ¤íŠ¸í•´ì•¼ í•  ì‚¬í•­ì„ ê³ ë ¤í•˜ëŠ” ê²ƒë¶€í„° ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤Â **`createTweet`**.

**íŠ¸ìœ—.service.ts**

`import { Injectable } from '@nestjs/common';

@Injectable() export class TweetsService { tweets: string[] = [];

createTweet(tweet: string) { if (tweet.length > 100) { throw new Error(`Tweet too long`); } this.tweets.push(tweet); return tweet; } }`

ì–´ë–¤ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•´ì•¼ í• ì§€ íŒŒì•…í•˜ëŠ” ë° ë„ì›€ì´ ë˜ë„ë¡ ë‹¤ìŒ ì§ˆë¬¸ì„ ìŠ¤ìŠ¤ë¡œì—ê²Œ ë¬¼ì–´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

"ì—¬ê¸°ì„œ ì˜ë„ëœ ë™ì‘ì€ ë¬´ì—‡ì…ë‹ˆê¹Œ? ì½”ë“œê°€ ë‚´ë ¤ê°ˆ ìˆ˜ ìˆëŠ” ê²½ë¡œê°€ ì—¬ëŸ¬ ê°œ ìˆìŠµë‹ˆê¹Œ?"

ë°©ë²• ì— ëŒ€í•œ ë‹¤ìŒ ì§ˆë¬¸ì— ë‹µí•´ ë³´ê² ìŠµë‹ˆë‹¤Â **`createTweets`**.

1. ìœ íš¨í•œ íŠ¸ìœ—ì´ ìƒì„±ë˜ë©´ í•´ë‹¹ íŠ¸ìœ—ì´ ìƒíƒœì— ì¶”ê°€ë©ë‹ˆë‹¤.
2. ìœ íš¨í•œ íŠ¸ìœ—ì´ ìƒì„±ë˜ë©´ ë©”ì„œë“œëŠ” í•´ë‹¹ íŠ¸ìœ—ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
3. ê¸¸ì´ê°€ 100ìë¥¼ ì´ˆê³¼í•˜ëŠ” íŠ¸ìœ—ì€ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì¢‹ì•„ìš”, ì´ì œ ì´ 3ê°€ì§€ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ë‹¤ë£¨ê¸° ìœ„í•œ ëª‡ ê°€ì§€ í…ŒìŠ¤íŠ¸ ì‘ì„±ì„ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤!

íŒŒì¼ ì—Â **`tweets.service.spec.ts`**ì²« ë²ˆì§¸ í…ŒìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

**íŠ¸ìœ—.service.spec.ts**

`import { Test, TestingModule } from '@nestjs/testing'; import { TweetsService } from './tweets.service';

describe('TweetsService', () => { let service: TweetsService;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ providers: [TweetsService], }).compile();

```
service = module.get<TweetsService>(TweetsService);
```

});

describe('createTweet', () => { it('should create tweet', () => { _// Arrange_ service.tweets = []; const payload = 'This is my tweet';

```
  *// Act*const tweet = service.createTweet(payload);

  *// Assert*expect(tweet).toBe(payload);
  expect(service.tweets).toHaveLength(1);
});
```

}); });`

ì´ í…ŒìŠ¤íŠ¸ì—ì„œ ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ê³  ìˆëŠ”ì§€ ë¶„ì„í•´ ë³´ê² ìŠµë‹ˆë‹¤.

1. **ë°°ì—´**
    
    : í…ŒìŠ¤íŠ¸ ì „ì— í˜ì´ë¡œë“œë¥¼ ë³€ìˆ˜ì— ë„£ì–´ ì•½ê°„ì˜ ì„¤ì •ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.
    
2. **Act**: Call theÂ **`createTweet`**Â method, the bit of behavior we are testing
    
3. **Assert**: Declare the intended outcome. Here we've checked that theÂ **`createTweet`**Â method returns the tweet that was passed into the payload. We've also tested that the in-memory state has been updated with the new tweet.
    

So we've now covered 2 of the 3 scenarios:

1. ~~When a valid tweet is created, it adds the tweet to state~~
2. ~~When a valid tweet is created, the method returns the respective tweet~~
3. A tweet greater than 100 characters in length should not be allowed

Let's add another test to handle the 3rd scenario!

**tweets.service.spec.ts**

`import { Test, TestingModule } from '@nestjs/testing'; import { TweetsService } from './tweets.service';

describe('TweetsService', () => { let service: TweetsService;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ providers: [TweetsService], }).compile();

```
service = module.get<TweetsService>(TweetsService);
```

});

describe('createTweet', () => { it('should create tweet', () => { _// ..._});

```
it('should prevent tweets created which are over 100 characters', () => {
  *// Arrange*const payload =
    'This is a long tweet over 100 characters This is a long tweet over 100 characters This is a long t...';

  *// Act*const tweet = () => {
    return service.createTweet(payload);
  };

  *// Assert*expect(tweet).toThrowError();
});
```

}); });`

Let's break down this test:

1. **Arrange**: We've done a bit of setup before the test by putting the payload in a variable
2. **Act**: Call theÂ **`createTweet`**Â method inside aÂ **`tweet()`**Â function.
3. **Assert**: Declare the intended outcome. Here we've checked that theÂ **`createTweet`**Â method throws an error with the payload passed in

TheÂ [**Arrange-Act-Assert**](https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/)Â is a good pattern to follow when writing tests. It helps keep the tests structured.

I won't include the Arrange-Act-Assert comments in any of the following examples, but I will follow this pattern so try to keep an eye out for it.

Time to practice your unit testing skills! Go ahead and write unit tests for the other methods in theÂ **`TweetsService`**. You can compare your work with the tests I've added in theÂ [**Github repo**](https://github.com/tomwray13/nestjs-unit-testing).

Once you've done that, let's move on to the next part of this tutorial.

![https://www.tomray.dev/static/images/nestjs.png](https://www.tomray.dev/static/images/nestjs.png)

**Free NestJS Course**Want to use NestJS to it's full potential and understand how it really works? Check out my free course which covers concepts like Dependency Injection, IoC Containers and more:**Your email addressGet free course**

## **Mocking with test doubles in NestJS**

So the previous example was quite simple. In theÂ **`TweetsService`**, we used 0 dependencies (i.e. nothing was passed into theÂ **`constructor`**), which simplifies our unit tests.

However, if you're working on a NestJS project, you'll soon find yourself adding dependencies to your services and controllers.

For example, theÂ **`TweetsService`**Â we defined in the previous step could evolve into something like:

**tweets.service.ts**

`import { Injectable } from '@nestjs/common'; import { HttpService } from '@nestjs/axios'; import { ConfigService } from '@nestjs/config';

@Injectable() export class TweetsService { constructor( private readonly httpService: HttpService, private readonly configService: ConfigService ) {} _// ..._}`

Adding these dependencies, however, will create some challenges for our unit tests.

Our methods can now include any one of the dependencies, so the scope of the unit tests has now extended to consider the behavior of the dependencies as well. Also, the dependencies can be asynchronous (e.g. using theÂ **`HttpService`**Â to make an HTTP request) which can affect the performance of our unit tests.

The solution? Test doubles.

In our unit tests, we can effectively swap out specific dependencies with a 'test double', so when the test runs it uses the test double instead of the actual dependency.

Let's dive into some examples:

### **Example: Mocking HTTP requests in NestJS**

Let's start by creating a newÂ **`pokemon`**Â module:

`nest g module pokemon`

And then add a pokemon service:

`nest g service pokemon`

Running these 2 commands will create a directory calledÂ **`pokemon`**Â with 3 files inside:

`src / pokemon / pokemon.module.ts pokemon.service.spec.ts pokemon.service.ts`

We're going to use theÂ [**NestJS HTTP module**](https://docs.nestjs.com/techniques/http-module)Â to fetch data from theÂ [**Pokemon API**](https://pokeapi.co/).

Let's install the relevant package:

`npm i --save @nestjs/axios@0.1.0`

When this article was published, there wasÂ [**a bug**](https://github.com/axios/axios/issues/5101)Â between Axios and Jest which is why I've installed theÂ **`0.1.0`**Â version!

In order to use the NestJS HTTP module in our service, we need to make it available for dependency injection by importing it into the module:

**pokemon.module.ts**

`import { HttpModule } from '@nestjs/axios'; import { Module } from '@nestjs/common'; import { PokemonService } from './pokemon.service';

@Module({ imports: [HttpModule], providers: [PokemonService], }) export class PokemonModule {}`

Now we can use theÂ **`HttpModule`**Â in the service by passing it into the constructor.

Inside the service file let's add a simpleÂ **`getPokemon`**Â method that returns the name of a Pokemon:

**pokemon.service.ts**

`import { HttpService } from '@nestjs/axios'; import { BadRequestException, Injectable, InternalServerErrorException, } from '@nestjs/common';

@Injectable() export class PokemonService { constructor(private httpService: HttpService) {}

async getPokemon(id: number) { if (id < 1 || id > 151) { throw new BadRequestException(`Invalid Pokemon ID`); }

```
const { data } = await this.httpService.axiosRef({
  url: `https://pokeapi.co/api/v2/pokemon/${id}`,
  method: `GET`,
});

if (!data || !data.species || !data.species.name) {
  throw new InternalServerErrorException();
}

return data.species.name;
```

} }`

Here is some unit tests we will add for the aboveÂ **`getPokemon()`**Â method:

1. An ID less thanÂ **`1`**Â should return aÂ **`BadRequestException`**
2. An ID greater thanÂ **`151`**Â should return aÂ **`BadRequestException`**
3. An ID betweenÂ **`1`**Â andÂ **`151`**Â returns the name of the respective pokemon
4. If the response from the Pokemon API isn't what we expect, then return aÂ **`InternalServerErrorException`**

Let's dive in!

NestJS auto-generated the test file for the Pokemon service:

**pokemon.service.spec.ts**

`import { Test, TestingModule } from '@nestjs/testing'; import { PokemonService } from './pokemon.service';

describe('PokemonService', () => { let service: PokemonService;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ providers: [PokemonService], }).compile();

```
service = module.get<PokemonService>(PokemonService);
```

});

it('should be defined', () => { expect(service).toBeDefined(); }); });`

WithÂ **`npm run test:watch`**Â running, however, you should see an error stating something likeÂ **`Nest can't resolve dependencies of the Pokemon Service`**:

[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271200%27%20height=%27559%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271200%27%20height=%27559%27/%3e)

data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7

You're seeing this error because Jest is trying to run the test but the testing instance is missing a dependency (the HTTP dependency, to be precise!).

So we need to provide the HTTP dependency to the testing module so that when the tests are run, the dependency we pass into the testing module can be used inside theÂ **`PokemonService`**.

This is one of the biggest benefits of dependency injection - you can swap out the dependency with a more appropriate alternative for testing purposes.

For example, we could pass in the actualÂ **`HttpService`**Â which makes HTTP requests to the Pokemon APIÂ **OR**Â we could pass in a 'test double' of theÂ **`HttpService`**Â which essentially pretends to make the HTTP requests.

This is super powerful!

With all that being said, for demonstration purposes let's start by implementing the tests which will make the actual HTTP requests to the Pokemon API. We'll then update our tests to mock the HTTP requests.

To fix the dependency error inside theÂ **`pokemon.service.spec.ts`**Â file, we just need to add theÂ **`HttpModule`**Â as an import to the test module:

**pokemon.service.spec.ts**

`import { HttpModule } from '@nestjs/axios'; import { Test, TestingModule } from '@nestjs/testing'; import { PokemonService } from './pokemon.service';

describe('PokemonService', () => { let pokemonService: PokemonService; _// renamed variable to pokemonService_beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ imports: [HttpModule], providers: [PokemonService], }).compile();

```
pokemonService = module.get<PokemonService>(PokemonService);
```

});

it('should be defined', () => { expect(pokemonService).toBeDefined(); }); });`

In the above test, I also renamed theÂ **`service`**Â variable toÂ **`pokemonService`**Â to make it more clear.

You should no longer see any testing errors in your terminal!

Let's recap the 4 unit tests we'd like to add:

1. An ID less thanÂ **`1`**Â should return aÂ **`BadRequestException`**
2. An ID greater thanÂ **`151`**Â should return aÂ **`BadRequestException`**
3. An ID betweenÂ **`1`**Â andÂ **`151`**Â returns the name of the respective pokemon
4. If the response from the Pokemon API isn't what we expect, then return aÂ **`InternalServerErrorException`**

Let's add those now:

**pokemon.service.spec.ts**

`import { HttpModule } from '@nestjs/axios'; import { BadRequestException } from '@nestjs/common'; import { Test, TestingModule } from '@nestjs/testing'; import { PokemonService } from './pokemon.service';

describe('PokemonService', () => { let pokemonService: PokemonService;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ imports: [HttpModule], providers: [PokemonService], }).compile();

```
pokemonService = module.get<PokemonService>(PokemonService);
```

});

it('should be defined', () => { expect(pokemonService).toBeDefined(); });

describe('getPokemon', () => { it('pokemon ID less than 1 should throw error', async () => { const getPokemon = pokemonService.getPokemon(0);

```
  await expect(getPokemon).rejects.toBeInstanceOf(BadRequestException);
});

it('pokemon ID greater than 151 should throw error', async () => {
  const getPokemon = pokemonService.getPokemon(152);

  await expect(getPokemon).rejects.toBeInstanceOf(BadRequestException);
});

it('valid pokemon ID to return the pokemon name', async () => {
  const getPokemon = pokemonService.getPokemon(1);

  await expect(getPokemon).resolves.toBe('bulbasaur');
});
```

}); });`

In the tests, we're dealing with asynchronous functions as theÂ **`getPokemon`**Â method returns a promise. That's what theÂ **`resolves`**Â andÂ **`rejects`**Â methods from Jest are handling.

Of course, you don't need to create theÂ **`getPokemon`**Â variable, but I find it a bit cleaner and makes the test easier to read instead of passing the method call directly into the JestÂ **`expect`**.

WithÂ **`npm run test:watch`**Â running, the tests should be passing!

As we've not done any mocking on theÂ **`Http`**Â dependency, when theÂ **`getPokemon`**Â methods are called in the 2 tests, the actualÂ **`Http`**Â dependency is being used (so in this case, attempting an HTTP request to the Pokemon API).

This has the following challenges:

- ğŸŒ Making network requests inside your tests will cause your test suite to be slower
- ğŸ’° Perhaps the API you're using costs money, so you only want the API to be called during runtime and not during tests
- ğŸ§˜â€â™€ï¸ The test should focus on the intended behavior of the method, regardless of any dependencies

So let's now explore how we can mock the HTTP service in NestJS.

To implement mocking in NestJS, I recommend using theÂ [**@golevelup/ts-jest**](https://www.npmjs.com/package/@golevelup/ts-jest)Â package.

Using theÂ **`createMock`**Â utility function from this package will give you all the properties and sub-properties for the thing you want to mock. The alternative is manually defining all the properties you need in a custom object (which can get quite repetitive).

When combined with Jest's mocking capabilities, it's very powerful.

Start by installing the package:

`npm install @golevelup/ts-jest`

So our objective here is to stop using the actual HTTP service which makes requests to the Pokemon API and instead implement a mocked version.

So instead of using theÂ **`HttpModule`**Â as an import in our testing module, we're going to replace theÂ **`HttpService`**Â directly using theÂ **`createMock()`**Â utility function:

**pokemon.service.spec.ts**

`import { createMock, DeepMocked } from '@golevelup/ts-jest'; import { HttpService } from '@nestjs/axios'; import { BadRequestException } from '@nestjs/common'; import { Test, TestingModule } from '@nestjs/testing'; import { PokemonService } from './pokemon.service';

describe('PokemonService', () => { let pokemonService: PokemonService; let httpService: DeepMocked<HttpService>;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ providers: [ PokemonService, { provide: HttpService, useValue: createMock<HttpService>(), }, ], }).compile();

```
pokemonService = module.get<PokemonService>(PokemonService);
httpService = module.get(HttpService);
```

});

_// ... tests_});`

TheÂ **`DeepMocked<HttpService>`**Â type makes sure theÂ **`httpService`**Â variable now has all the properties and sub-properties available in your IDE for auto-completion.

What impact does the above changes have on your tests?

Well, for example, one of the tests we defined was to ensure when a valid Pokemon ID is passed in, it returns the respective Pokemon name:

**pokemon.service.spec.ts**

`*// ...*it('valid pokemon ID to return the pokemon name', async () => { const getPokemon = pokemonService.getPokemon(1);

await expect(getPokemon).resolves.toBe('bulbasaur'); });`

In this test, we're calling theÂ **`getPokemon`**Â method. If you look in theÂ **`getPokemon`**Â method, you'll see theÂ **`HttpService`**Â is used to make a request to the Pokemon API.

We've basically replaced theÂ **`HttpService`**Â with a dummy function that we can control in our tests.

So if you're following on with the tutorial and still haveÂ **`npm run test:watch`**Â running, you'll see an error like this:

[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271200%27%20height=%27632%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271200%27%20height=%27632%27/%3e)

data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7

This is because our dummy function isn't doing anything!

In this test, let's update the dummy function to 'mock' the response from the Pokemon API:

**pokemon.service.spec.ts**

`import { createMock, DeepMocked } from '@golevelup/ts-jest'; import { HttpService } from '@nestjs/axios'; import { BadRequestException } from '@nestjs/common'; import { Test, TestingModule } from '@nestjs/testing'; import { PokemonService } from './pokemon.service';

describe('PokemonService', () => { let pokemonService: PokemonService; let httpService: DeepMocked<HttpService>;

beforeEach(async () => { _// setup..._});

describe('getPokemon', () => { *// other tests...*it('valid pokemon ID to return the pokemon name', async () => { httpService.axiosRef.mockResolvedValueOnce({ data: { species: { name: `bulbasaur` }, }, headers: {}, config: { url: '' }, status: 200, statusText: '', });

```
  const getPokemon = pokemonService.getPokemon(1);

  await expect(getPokemon).resolves.toBe('bulbasaur');
});
```

}); });`

We're implementing a mock to tell the test: "Hey, whenever you run this test, make sure the httpService call returns an Axios response with the specific object inside theÂ **`data`**Â property".

Your test should now be passing.

By the way, you may have noticed that we're missing a test to cover the 4th scenario:

1. ~~An ID less than 1 should return a BadRequestException~~
2. ~~An ID greater than 151 should return a BadRequestException~~
3. ~~An ID between 1 and 151 returns the name of the respective pokemon~~
4. If the response from the Pokemon API isn't what we expect, then return anÂ **`InternalServerErrorException`**

Let's add a final test for this:

**pokemon.service.spec.ts**

`import { createMock, DeepMocked } from '@golevelup/ts-jest'; import { HttpService } from '@nestjs/axios'; import { BadRequestException } from '@nestjs/common'; import { Test, TestingModule } from '@nestjs/testing'; import { PokemonService } from './pokemon.service';

describe('PokemonService', () => { let pokemonService: PokemonService; let httpService: DeepMocked<HttpService>;

beforeEach(async () => { _// setup..._});

describe('getPokemon', () => { *// other tests...*it('if Pokemon API response unexpectedly changes, throw an error', async () => { httpService.axiosRef.mockResolvedValueOnce({ data: `Unexpected data`, headers: {}, config: { url: '' }, status: 200, statusText: '', });

```
  const getPokemon = pokemonService.getPokemon(1);

  await expect(getPokemon).rejects.toBeInstanceOf(
    InternalServerErrorException,
  );
});
```

}); });`

One final optimization we can make to ourÂ **`PokemonService`**Â test file is clean up theÂ **`beforeEach`**Â hook a little.

Here's how it looks again:

**pokemon.service.spec.ts**

`*// imports...*describe('PokemonService', () => { let pokemonService: PokemonService; let httpService: DeepMocked<HttpService>;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ providers: [ PokemonService, { provide: HttpService, useValue: createMock<HttpService>(), }, ], }).compile();

```
pokemonService = module.get<PokemonService>(PokemonService);
httpService = module.get(HttpService);
```

});

_// the tests..._});`

Let's say ourÂ **`PokemonService`**Â grows and we add more dependencies like caching and logging:

**pokemon.service.spec.ts**

`*// imports...*describe('PokemonService', () => { let pokemonService: PokemonService; let httpService: DeepMocked<HttpService>;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ providers: [ PokemonService, { provide: HttpService, useValue: createMock<HttpService>(), }, { provide: CacheService, useValue: createMock<CacheService>(), }, { provide: LoggingService, useValue: createMock<LoggingService>(), }, ], }).compile();

```
pokemonService = module.get<PokemonService>(PokemonService);
httpService = module.get(HttpService);
```

});

_// the tests..._});`

Adding a new object to theÂ **`providers`**Â array can get a little tedious every time we want to mock a dependency.

Thankfully, NestJS released in V8 a feature called Auto mocking which makes this code much cleaner:

**pokemon.service.spec.ts**

`*// imports...*describe('PokemonService', () => { let pokemonService: PokemonService; let httpService: DeepMocked<HttpService>;

beforeEach(async () => { const module: TestingModule = await Test.createTestingModule({ providers: [ PokemonService ], }) .useMocker(createMock) .compile();

```
pokemonService = module.get<PokemonService>(PokemonService);
httpService = module.get(HttpService);
```

});

_// the tests..._});`

PassingÂ **`createMock`**Â into theÂ **`useMocker()`**Â method essentially mocks any dependency you haven't defined in the testing module.

Thank youÂ [**Thiago Martins**](https://twitter.com/thiagomni)Â forÂ [**the tip**](https://trilon.io/blog/advanced-testing-strategies-with-mocks-in-nestjs)Â on this!

Nice work!

You've now done a deep dive into implementing test doubles in NestJS ğŸ¤Ÿ.

## **Unit testing pipes in NestJS**

[**Pipes**](https://docs.nestjs.com/pipes)Â in NestJS are a way to validate and transform any inputs passed into your controllers.

There are a few built-in ones, likeÂ **`ParseIntPipe`**Â that converts the specified parameter into an integer, returning aÂ **`404`**Â if the conversion fails.

Here's an example of how theÂ **`ParseIntPipe`**Â could be implemented into a controller:

**pokemon.controller.ts**

`import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common'; import { PokemonService } from './pokemon.service';

@Controller('pokemon') export class PokemonController { constructor(private readonly pokemonService: PokemonService) {}

@Get(':id') getPokemon(@Param('id', ParseIntPipe) id: number) { return this.pokemonService.getPokemon(id); } }`

Let's say that as well as theÂ **`:id`**Â parameter being a number, we want to ensure that the value is greater thanÂ **`0`**Â and less thanÂ **`152`**. We could implement something like this in the controller:

**pokemon.controller.ts**

`import { BadRequestException, Controller, Get, Param, ParseIntPipe, } from '@nestjs/common'; import { PokemonService } from './pokemon.service';

@Controller('pokemon') export class PokemonController { constructor(private readonly pokemonService: PokemonService) {}

@Get(':id') getPokemon(@Param('id', ParseIntPipe) id: number) { if (id < 0 || id > 151) { throw new BadRequestException(`Invalid Pokemon ID`); } return this.pokemonService.getPokemon(id); } }`

Or we could create a custom pipe that handles this for us! Let's add this custom pipe, then add some unit tests for it.

Using the Nest CLI, create a new pipe:

`nest g pipe parse-pokemon-id`

This will create 2 new files in the root of yourÂ **`/src`**Â folder:

`src/ ... parse-pokemon-id.pipe.spec.ts parse-pokemon-id.pipe.ts`

You can move these files into theÂ **`pokemon`**Â directory if you like!

Let's update the pipe to achieve the specified behavior:

**parse-pokemon.pipe.ts**

`import { BadRequestException, Injectable, PipeTransform } from '@nestjs/common';

@Injectable() export class ParsePokemonIdPipe implements PipeTransform { transform(value: string): number { const id = parseInt(value); if (isNaN(id)) { throw new BadRequestException( `Validation failed (numeric string is expected)`, ); } if (id < 1 || id > 151) { throw new BadRequestException(`ID must be between 1 and 151`); } return id; } }`

This pipe we've created could do with the following tests:

1. Should throw an error for nonnumbers
2. Should throw an error if the number is less than 1 or greater than 151
3. Should return the number if between 1 and 151

Open up the pipe test file Nest created for us:

**parse-pokemon-id.pipe.spec.ts**

`import { ParsePokemonIdPipe } from './parse-pokemon-id.pipe';

describe('ParsePokemonIdPipe', () => { it('should be defined', () => { expect(new ParsePokemonIdPipe()).toBeDefined(); }); });`

Let's use a similar structure to previous unit tests: use aÂ **`beforeEach`**Â hook to create a reusableÂ **`pipe`**Â variable across all the tests:

**parse-pokemon-id.pipe.spec.ts**

`import { ParsePokemonIdPipe } from './parse-pokemon-id.pipe';

describe('ParsePokemonIdPipe', () => { let pipe: ParsePokemonIdPipe;

beforeEach(() => { pipe = new ParsePokemonIdPipe(); });

_// ... now we can write tests using the pipe_});`

With that set-up, let's add the tests!

**parse-pokemon-id.pipe.spec.ts**

`import { BadRequestException } from '@nestjs/common'; import { ParsePokemonIdPipe } from './parse-pokemon-id.pipe';

describe('ParsePokemonIdPipe', () => { let pipe: ParsePokemonIdPipe;

beforeEach(() => { pipe = new ParsePokemonIdPipe(); });

it('should be defined', () => { expect(new ParsePokemonIdPipe()).toBeDefined(); });

it(`should throw error for non numbers`, () => { const value = () => pipe.transform(`hello`); expect(value).toThrowError(BadRequestException); });

it(`should throw error if number less than 1`, () => { const value = () => pipe.transform(`-34`); expect(value).toThrowError(BadRequestException); });

it(`should throw error if number greater than 151`, () => { const value = () => pipe.transform(`200`); expect(value).toThrowError(BadRequestException); });

it(`should return number if between 1 and 151`, () => { const value = () => pipe.transform(`5`); expect(value()).toBe(5); }); });`

ì˜ í•˜ì…¨ì–´ìš”! ì´ì œ NestJSì—ì„œ íŒŒì´í”„ë¥¼ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸í•˜ëŠ” ë°©ë²•ì„ ì•Œì•˜ìŠµë‹ˆë‹¤.

## **Github Actionsë¥¼ ì‚¬ìš©í•˜ì—¬ CI íŒŒì´í”„ë¼ì¸ì—ì„œ NestJS ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ìë™í™”**

ë¡œì»¬ì—ì„œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ëŠ” ê²ƒë„ ì¢‹ì§€ë§Œ,Â í’€ ìš”ì²­ì´ë‚˜ íŠ¹ì • ë¸Œëœì¹˜ì— ëŒ€í•œ í‘¸ì‹œ ì»¤ë°‹ê³¼ ê°™ì€ ì£¼ìš” íŠ¸ë¦¬ê±°ì—ì„œ í…ŒìŠ¤íŠ¸ê°€ ìë™í™”ë˜ë„ë¡Â [**ì§€ì†ì ì¸ í†µí•© ì›Œí¬í”Œë¡œë¥¼ ê³§ ì„¤ì •í•˜ê³  ì‹¶ì„ ê²ƒì…ë‹ˆë‹¤.**](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration)

[**Github Actionsë¥¼**](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions)Â ì‚¬ìš©í•˜ë©´ ì‰½ê²Œ ì„¤ì •í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œÂ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—Â **`.github/workflows/`**ë””ë ‰í„°ë¦¬ë¥¼ ë§Œë“­ë‹ˆë‹¤.

ë””ë ‰í„°ë¦¬ ì—ì„œÂ **`.github/workflows/`**í…ŒìŠ¤íŠ¸.ymlì´ë¼ëŠ” ìƒˆ íŒŒì¼ì„ ë§Œë“¤ê³  ë‹¤ìŒ ì½”ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

**í…ŒìŠ¤íŠ¸.yml**

`name: Tests on: pull_request jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Install modules run: npm ci - name: Run tests run: npm run test`

ì´ íŒŒì¼ì˜ ë‚´ìš©ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

- **`on:`**
    
    ìë™í™”ê°€ íŠ¸ë¦¬ê±°ë  ì´ë²¤íŠ¸ë¥¼ ì •ì˜í•©ë‹ˆë‹¤Â .Â ë”°ë¼ì„œ ì—´ë ¤ ìˆëŠ” ëª¨ë“  ëŒì–´ì˜¤ê¸° ìš”ì²­ì€ ìë™í™”ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
    
- ë‹¤ìŒìœ¼ë¡œ, ê°€ìƒ ë¨¸ì‹ ì„ ê°€ë™í•˜ê³  ë‹¤ìŒ ë‹¨ê³„ë¥¼ ì‹¤í–‰í•˜ëŠ” ì‘ì—…ì„ ì •ì˜í–ˆìŠµë‹ˆë‹¤.
    
    1. ë¨¼ì € Github ActionÂ [**actions/checkout@v3 ì„**](https://github.com/actions/checkout)
        
        ì‹¤í–‰í•©ë‹ˆë‹¤ . ì´ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ìë™í™”ê°€ ì €ì¥ì†Œì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆë„ë¡ í—ˆìš©í•˜ëŠ” ì¸ì¦ ë‹¨ê³„ì…ë‹ˆë‹¤.
        
    2. ë‹¤ìŒìœ¼ë¡œ ë¨¸ì‹ ì€ ë‹¤ìŒì„ ì‚¬ìš©í•˜ì—¬ ì¢…ì†ì„±ì„ ì„¤ì¹˜í•©ë‹ˆë‹¤.**`npm ci`**
        
    3. ê·¸ë¦¬ê³  ë§ˆì§€ë§‰ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
        

ì´ì œ ì½”ë“œë¥¼ Githubì— í‘¸ì‹œí•˜ê³  í’€ ìš”ì²­ì„ ì—´ë©´ í…ŒìŠ¤íŠ¸ê°€ ìë™ìœ¼ë¡œ ì‹¤í–‰ë˜ê³  í’€ ìš”ì²­ ë‚´ì—ì„œ í…ŒìŠ¤íŠ¸ê°€ í†µê³¼ë˜ì—ˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272400%27%20height=%271782%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272400%27%20height=%271782%27/%3e)

[https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fautomated-test-pull-request.png&w=3840&q=75](https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fautomated-test-pull-request.png&w=3840&q=75)

ë˜í•œ ì›Œí¬í”Œë¡œê°€ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ ì‘ì—…ì˜ ë‹¨ê³„ì™€ ì¶œë ¥ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272400%27%20height=%271377%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272400%27%20height=%271377%27/%3e)

[https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fgithub-jobs.png&w=3840&q=75](https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fgithub-jobs.png&w=3840&q=75)

í”„ë¡œì íŠ¸ì— í…ŒìŠ¤íŠ¸ê°€ ì˜ì¡´í•˜ëŠ” í™˜ê²½ ë³€ìˆ˜ê°€ ìˆëŠ” ê²½ìš° Github ì‘ì—…ì—ì„œ ìë™í™”ëœ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•  ë•Œ ì˜¤ë¥˜ê°€ í‘œì‹œë©ë‹ˆë‹¤.

ë‹¤ìŒê³¼ ê°™ì´ ì›Œí¬í”Œë¡œì—ì„œ í™˜ê²½ ë³€ìˆ˜ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤.

**í…ŒìŠ¤íŠ¸.yml**

`name: Tests on: pull_request env: API_KEY: "an-api-key" jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Install modules run: npm ci - name: Run tests run: npm run test`

í™˜ê²½ ë³€ìˆ˜ê°€ ë¯¼ê°í•œ ê²½ìš°(ì˜ˆ: API í‚¤) Github Secretsë¥¼ ëŒ€ì‹  ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

ì €ì¥ì†Œì—ì„œ ì„¤ì • íƒ­ìœ¼ë¡œ ì´ë™í•˜ì—¬ ë¹„ë°€ì„ ì¶”ê°€í•˜ì„¸ìš”.

[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272400%27%20height=%271643%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272400%27%20height=%271643%27/%3e)

[https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fgithub-secrets.png&w=3840&q=75](https://www.tomray.dev/_next/image?url=%2Fstatic%2Fimages%2Fnestjs-unit-testing%2Fgithub-secrets.png&w=3840&q=75)

ê·¸ëŸ° ë‹¤ìŒ ëŒ€ì‹  ë¹„ë°€ì„ ì‚¬ìš©í•˜ë„ë¡ ì›Œí¬í”Œë¡œë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

**í…ŒìŠ¤íŠ¸.yml**

`name: Tests on: pull_request env: API_KEY: ${{ secrets.API_KEY }} jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Install modules run: npm ci - name: Run tests run: npm run test`

ì˜í•˜ì…¨ìŠµë‹ˆë‹¤. ì´ì œ í”„ë¡œì íŠ¸ì—ì„œ ëŒì–´ì˜¤ê¸° ìš”ì²­ì´ ì—´ë¦´ ë•Œë§ˆë‹¤ ìë™ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

ì´ë¥¼ ì§€ì†ì ì¸ ì „ë‹¬ ì›Œí¬í”Œë¡œ(Â [**Github Actionsë¡œë„ ì„¤ì •í• also set up with Github Actions**](https://www.tomray.dev/deploy-nestjs-cloud-run)Â ìˆ˜ ìˆìŒ )ì™€ ê²°í•©í•˜ë©´ ìë™í™”ëœ CI/CD íŒŒì´í”„ë¼ì¸ì´ ìƒì„±ë©ë‹ˆë‹¤.

[Ultimate Guide: NestJS Unit Testing and Mocking [Updated 2022]](https://www.tomray.dev/nestjs-unit-testing#automating-nestjs-unit-tests-in-a-ci-pipeline-with-github-actions)